<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Location-Based Weather Widget</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <!-- Fix 1: Using minified Tailwind CSS instead of the dev CDN -->
  <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://unpkg.com/lucide-react@0.263.1/dist/umd/lucide-react.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    #root {
      height: 100%;
      width: 100%;
    }
    .clip-triangle {
      clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    }
    #error-log {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      max-height: 100px;
      overflow: auto;
      z-index: 1000;
      display: none;
    }
    /* Add custom background gradients that don't depend on Tailwind */
    .bg-blue-gradient {
      background: linear-gradient(to right, #4299e1, #3182ce);
    }
    .bg-day-clear {
      background: linear-gradient(to right, #4facfe, #00f2fe);
    }
    .bg-morning-clear {
      background: linear-gradient(to right, #ffd166, #118ab2);
    }
    .bg-evening-clear {
      background: linear-gradient(to right, #ff9e68, #9561e2);
    }
    .bg-night-clear {
      background: linear-gradient(to right, #2b4162, #12100e);
    }
    .bg-clouds {
      background: linear-gradient(to right, #bdc3c7, #2c3e50);
    }
    .glass-card {
      background-color: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      border-radius: 0.5rem;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="error-log"></div>
  
  <!-- Helper function to log errors visibly -->
  <script>
    // Create a visible error log for debugging
    function logError(message) {
      const errorLog = document.getElementById('error-log');
      errorLog.style.display = 'block';
      errorLog.innerHTML += message + '<br>';
      console.error(message);
    }
    
    // Capture global errors
    window.onerror = function(message, source, lineno, colno, error) {
      logError(`ERROR: ${message} at ${source}:${lineno}:${colno}`);
      return false;
    };
  </script>

  <script type="text/babel">
    const { useState, useEffect } = React;
    const { Cloud, Thermometer, Sun, Droplets, MapPin, Wind } = window.LucideReact;
    
    // API keys
    const openWeatherMapApiKey = 'f5aa6727832f8af0e6b896eca32ed755';
    const opencageApiKey = '0af25ade0fe24adea501d091fe8c04fc';

    // Force HTTPS for all API calls
    function ensureHttps(url) {
      return url.replace('http://', 'https://');
    }

    const WeatherWidget = () => {
      // Always start with demo mode true - this ensures we show something
      const [useDemo, setUseDemo] = useState(true);
      const [weatherData, setWeatherData] = useState(null);
      const [location, setLocation] = useState('');
      const [countryCode, setCountryCode] = useState('');
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [timeOfDay, setTimeOfDay] = useState('day');
      const [locationType, setLocationType] = useState('city');
      const [statusMessage, setStatusMessage] = useState('Initializing...');

      // Set up demo data immediately to avoid white screen
      useEffect(() => {
        setDemoData();
        // Try to load real data after demo is shown
        if (!useDemo) {
          tryLoadRealData();
        }
      }, [useDemo]);

      // Function to set demo data
      const setDemoData = () => {
        setWeatherData({
          temp: 22,
          feels_like: 24,
          temp_min: 18,
          temp_max: 27,
          description: 'scattered clouds',
          main: 'Clouds',
          wind: 3.5,
          humidity: 65,
          icon: '03d'
        });
        setLocation('New Delhi');
        setCountryCode('IN');
        setTimeOfDay('day');
        setLocationType('city');
        setLoading(false);
        setStatusMessage('Using demo data');
      };

      // Function to try loading real data
      const tryLoadRealData = () => {
        try {
          setStatusMessage('Requesting location permission...');
          
          if (!navigator.geolocation) {
            throw new Error('Geolocation is not supported by your browser');
          }
          
          navigator.geolocation.getCurrentPosition(
            position => {
              setStatusMessage('Location permission granted');
              const { latitude, longitude } = position.coords;
              fetchWeatherData(latitude, longitude);
              fetchLocationDetails(latitude, longitude);
              determineTimeOfDay();
            },
            err => {
              setStatusMessage(`Location error: ${err.message}`);
              logError(`Geolocation error (${err.code}): ${err.message}`);
              setError('Location access denied. Please enable location services and reload.');
              setLoading(false);
            },
            { timeout: 10000, maximumAge: 60000 }
          );
        } catch (err) {
          setStatusMessage(`Error: ${err.message}`);
          logError(`General error: ${err.message}`);
          setError('Could not initialize location services. Using demo data instead.');
          setLoading(false);
        }
      };

      const determineTimeOfDay = () => {
        const now = new Date();
        const hour = now.getHours();
        setStatusMessage(`Current hour: ${hour}`);
        
        if (hour >= 5 && hour < 12) {
          setTimeOfDay('morning');
        } else if (hour >= 12 && hour < 17) {
          setTimeOfDay('day');
        } else if (hour >= 17 && hour < 20) {
          setTimeOfDay('evening');
        } else {
          setTimeOfDay('night');
        }
      };

      const fetchLocationDetails = async (lat, lon) => {
        try {
          setStatusMessage('Fetching location details...');
          const url = ensureHttps(`https://api.opencagedata.com/geocode/v1/json?q=${lat}+${lon}&key=${opencageApiKey}`);
          
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error(`OpenCage API returned status ${response.status}`);
          }
          
          const data = await response.json();
          setStatusMessage('Location data received');
          
          if (data.results && data.results.length > 0) {
            const result = data.results[0];
            const components = result.components;
            
            // Set location name
            const city = components.city || 
                        components.town || 
                        components.village || 
                        components.state;
            setLocation(city);
            
            // Fix 2: Remove optional chaining operator (?.) that was causing Babel errors
            // Original: setCountryCode(components.country_code?.toUpperCase() || '');
            const countryCodeValue = components.country_code ? components.country_code.toUpperCase() : '';
            setCountryCode(countryCodeValue);
            
            // Determine location type based on OpenCage categories or components
            if (components.city) {
              setLocationType('city');
            } else if (components.village || components.hamlet) {
              setLocationType('rural');
            } else if (components.coast || components.sea || components.ocean) {
              setLocationType('coastal');
            } else if (components.mountain || components.peak) {
              setLocationType('mountains');
            } else if (components.desert) {
              setLocationType('desert');
            } else if (components.forest || components.woodland) {
              setLocationType('forest');
            } else {
              // Check if it's near water - Fix: removed optional chaining
              const isNearWater = result.annotations && 
                                 result.annotations.DMS && 
                                 result.annotations.DMS.lat &&
                                 result.annotations.DMS.lat.includes('N') && 
                                 (Math.abs(lat) < 30) && // Within tropical or subtropical zones
                                 result.annotations.DMS.lng &&
                                 result.annotations.DMS.lng.includes('E');
              
              if (isNearWater) {
                setLocationType('tropical');
              }
            }
          } else {
            throw new Error('No results found in OpenCage response');
          }
        } catch (error) {
          setStatusMessage(`Location error: ${error.message}`);
          logError(`Error fetching location details: ${error.message}`);
        }
      };

      const fetchWeatherData = async (lat, lon) => {
        try {
          setStatusMessage('Fetching weather data...');
          const url = ensureHttps(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${openWeatherMapApiKey}`);
          
          const response = await fetch(url);
          
          if (!response.ok) {
            throw new Error(`OpenWeatherMap API returned status ${response.status}`);
          }
          
          const data = await response.json();
          setStatusMessage('Weather data received');
          
          setWeatherData({
            temp: Math.round(data.main.temp),
            feels_like: Math.round(data.main.feels_like),
            temp_min: Math.round(data.main.temp_min),
            temp_max: Math.round(data.main.temp_max),
            description: data.weather[0].description,
            main: data.weather[0].main,
            wind: data.wind.speed,
            humidity: data.main.humidity,
            icon: data.weather[0].icon
          });
          setLoading(false);
          setError(null);
          setUseDemo(false);
        } catch (error) {
          setStatusMessage(`Weather error: ${error.message}`);
          logError(`Error fetching weather data: ${error.message}`);
          setError('Error getting weather data. Using demo data instead.');
          setLoading(false);
        }
      };

      // Simplified getBackgroundStyle that doesn't rely as much on Tailwind classes
      const getBackgroundStyle = () => {
        const weatherType = weatherData?.main || 'Clear';
        
        // Create a simple class mapping
        if (weatherType === 'Clear') {
          if (timeOfDay === 'morning') return 'bg-morning-clear';
          if (timeOfDay === 'evening') return 'bg-evening-clear';
          if (timeOfDay === 'night') return 'bg-night-clear';
          return 'bg-day-clear';
        }
        
        if (weatherType === 'Clouds' || weatherType === 'Rain' || 
            weatherType === 'Drizzle' || weatherType === 'Mist' ||
            weatherType === 'Fog' || weatherType === 'Haze') {
          return 'bg-clouds';
        }
        
        // Default
        return 'bg-blue-gradient';
      };

      if (loading) {
        return (
          <div className="flex items-center justify-center w-full h-full bg-blue-gradient text-white rounded-lg shadow-lg p-6">
            <div className="text-center">
              <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-white mx-auto mb-2"></div>
              <p>{statusMessage}</p>
            </div>
          </div>
        );
      }

      const getWeatherIcon = () => {
        const main = weatherData?.main;
        if (main === 'Clear') {
          return timeOfDay === 'night' ? '🌙' : '☀️';
        } else if (main === 'Clouds') {
          return '☁️';
        } else if (main === 'Rain') {
          return '🌧️';
        } else if (main === 'Snow') {
          return '❄️';
        } else if (main === 'Thunderstorm') {
          return '⛈️';
        } else if (main === 'Drizzle') {
          return '🌦️';
        } else if (main === 'Mist' || main === 'Fog' || main === 'Haze') {
          return '🌫️';
        }
        return '🌤️';
      };

      // Toggle button to switch between demo and live
      const toggleDemoMode = () => {
        setUseDemo(!useDemo);
        setLoading(true); // Restart loading process
      };

      // Function to show debug panel
      const showDebugInfo = () => {
        const errorLog = document.getElementById('error-log');
        errorLog.style.display = errorLog.style.display === 'block' ? 'none' : 'block';
      };

      return (
        <div className={`w-full h-full ${getBackgroundStyle()} text-white rounded-lg shadow-lg overflow-hidden`}>
          <div className="p-6 h-full flex flex-col relative glass-card">
            {/* Demo mode toggle and debug button */}
            <div className="absolute top-2 right-2 z-20 flex gap-2">
              <button 
                onClick={toggleDemoMode}
                className="text-xs bg-black bg-opacity-30 px-2 py-1 rounded hover:bg-opacity-50"
              >
                {useDemo ? "Try Live Data" : "Use Demo Data"}
              </button>
              <button 
                onClick={showDebugInfo}
                className="text-xs bg-red-500 bg-opacity-30 px-2 py-1 rounded hover:bg-opacity-50"
              >
                Debug
              </button>
            </div>
            
            {/* Status message */}
            {statusMessage && (
              <div className="absolute top-2 left-2 z-20">
                <span className="text-xs bg-black bg-opacity-30 px-2 py-1 rounded">{statusMessage}</span>
              </div>
            )}
            
            {/* Location decorations based on type */}
            {locationType === 'city' && (
              <div className="absolute bottom-0 left-0 right-0 h-16 bg-black bg-opacity-20">
                <div className="w-full h-full flex items-end justify-around">
                  <div className="w-6 h-12 bg-white bg-opacity-20 rounded-t"></div>
                  <div className="w-8 h-16 bg-white bg-opacity-20 rounded-t"></div>
                  <div className="w-12 h-10 bg-white bg-opacity-20 rounded-t"></div>
                  <div className="w-10 h-14 bg-white bg-opacity-20 rounded-t"></div>
                  <div className="w-7 h-8 bg-white bg-opacity-20 rounded-t"></div>
                </div>
              </div>
            )}
            
            {locationType === 'mountains' && (
              <div className="absolute bottom-0 left-0 right-0 h-20 flex items-end">
                <div className="w-full h-full flex items-end">
                  <div className="w-1/3 h-20 bg-white bg-opacity-10 clip-triangle transform translate-y-2"></div>
                  <div className="w-1/4 h-16 bg-white bg-opacity-10 clip-triangle transform -translate-x-8"></div>
                  <div className="w-1/2 h-12 bg-white bg-opacity-10 clip-triangle transform -translate-x-16 translate-y-4"></div>
                </div>
              </div>
            )}
            
            {locationType === 'coastal' && (
              <div className="absolute bottom-0 left-0 right-0 h-12">
                <div className="w-full h-full flex items-end">
                  <div className="w-full h-6 bg-white bg-opacity-20 rounded-t-full"></div>
                </div>
              </div>
            )}
            
            {/* Header with location */}
            <div className="flex items-center justify-between mb-2 z-10">
              <div className="flex items-center">
                <MapPin className="h-5 w-5 mr-1" />
                <h2 className="text-2xl font-bold">{location || 'Weather'}</h2>
                {countryCode && <span className="ml-1 text-sm bg-white bg-opacity-20 px-1 rounded">{countryCode}</span>}
              </div>
              <div className="flex items-center text-sm">
                <span>{weatherData?.description || 'Weather data'}</span>
              </div>
            </div>
            
            {/* Main temperature display */}
            <div className="flex-1 flex items-center justify-center z-10">
              <div className="flex items-center">
                <span className="text-6xl mr-4">{getWeatherIcon()}</span>
                <div className="text-7xl font-bold flex items-start">
                  {weatherData?.temp || '--'}
                  <span className="text-3xl mt-1">°C</span>
                </div>
              </div>
            </div>
            
            {/* Weather details */}
            <div className="grid grid-cols-4 gap-2 mt-2 z-10">
              <div className="flex flex-col items-center glass-card p-2">
                <div className="flex items-center text-sm mb-1">
                  <Thermometer className="h-4 w-4 mr-1" />
                  <span>Feels</span>
                </div>
                <span className="font-bold">{weatherData?.feels_like || '--'}°C</span>
              </div>
              
              <div className="flex flex-col items-center glass-card p-2">
                <div className="flex items-center text-sm mb-1">
                  <Sun className="h-4 w-4 mr-1" />
                  <span>High</span>
                </div>
                <span className="font-bold">{weatherData?.temp_max || '--'}°C</span>
              </div>
              
              <div className="flex flex-col items-center glass-card p-2">
                <div className="flex items-center text-sm mb-1">
                  <Droplets className="h-4 w-4 mr-1" />
                  <span>Low</span>
                </div>
                <span className="font-bold">{weatherData?.temp_min || '--'}°C</span>
              </div>
              
              <div className="flex flex-col items-center glass-card p-2">
                <div className="flex items-center text-sm mb-1">
                  <Wind className="h-4 w-4 mr-1" />
                  <span>Wind</span>
                </div>
                <span className="font-bold">{weatherData?.wind || '--'} m/s</span>
              </div>
            </div>
            
            {/* Error message if any */}
            {error && (
              <div className="absolute bottom-4 left-4 right-4 bg-red-500 bg-opacity-80 text-white p-2 rounded z-20 text-sm">
                {error}
              </div>
            )}
          </div>
        </div>
      );
    };

    try {
      ReactDOM.render(<WeatherWidget />, document.getElementById('root'));
    } catch (error) {
      logError(`Render error: ${error.message}`);
      document.getElementById('root').innerHTML = `
        <div style="padding: 20px; color: white; background: #e63946; border-radius: 8px;">
          <h2>Error Loading Weather Widget</h2>
          <p>${error.message}</p>
          <p>Please check the browser console for more details.</p>
        </div>
      `;
    }
  </script>
</body>
</html>
